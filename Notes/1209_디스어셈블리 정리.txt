캐시 히트 - cpu 에서 l1을 거쳐 바로 돌아오는거

캐시 미스



예전엔 메인보드에 있던 캐시메모리가 다 빠져있다 
코어가 요즘엔 여러개라 캐시메모리가 코어마다 있다면? 캐시메모리간의 동기호ㅏ문제. 그럴땐 다른 캐시에게 지우라고 알려줌 
지금 인텔에서는 l1까지는 코어마다 있고 l2부터는 공용으로 있음 


x86 은 레지스터에 대한 규격. x86 으로 맞춰진 cpu는 빌드햇을ㄹ때 똑같이 돌아감. 
32비트와 64비트의 차이는? 레지스터의 크기. 32비트는 연산을할때 4바이트씩밖에 못긁어옴  

bp : 16비트 레지스터
ebp : 32비트 
rbp : 64비트 
어떤 실행파일이 몇비트인지 모르겠으면 어셈블리 코드를 보고 파악할수있음 32비트는 다 e가 앞에 붙는다 .

esp : 스택메모리의 top. 
esp 1000 이라고 들어있으면 스택의 top이 1000번지에 있는것 push 5면 여기에 5를 넣는것 그리고 스택을 한칸 올리면 996
pop 을 하면 거기 있는 값을 뽑고 스택을 내림 1000으로. 현재 프로그램에 top의 위치. 지역변수 선언하면 스택에 선언되는데 그 의미가 이거
스택을 올려서 공간확보. 그럼 그 구간이 스택메모리가 됨. 4바이트 10개 선언 --> esp에 40을 빼면 960으로 top이 올라감. 이게 지역변수 

ebp : base pointer. 함수 안에있는 변수는 스택의 어디에 있느냐? 컴파일 하면 a변수는 메모리에서 0x4936으로 하드코딩하지않는다 
호출위치에따라 main인지 함수 몇번 호출한 뒨지에 따라 변수의 위치가 달라진다. 주소값자체를 주소값으로 표현못함ㅎ 
그래서 결국 상대주소가 필요. 나의 스택 의 상대주소 esp라는 스택의 top은 알겠는데, esp가 어디일지 모름. 
a함수의 스택, b함수 스택, main함수 스택 의 구분 기준이 ebp. 모든 함수의 구분은 ebp를 기준. 내 함수 스택의 바닥.
main이 호출되면 그 스택의 바닥이 ebp. b가 호출되면 그 b스택의 바닥이 ebp. b스택의 꼭대기가 esp로 잡힘 
ebp부터 지역변수의 주소가 잡힘.. a함수가 리턴되면 그 밑의 b스택의 위치로 ebp와 esp를 복구시켜야함. 
복구 되어야 할 원래 위치도 스택에 저장되어있음


eax : 범용 . 덧셈 뺄셈

ecx : 반복문 등의 카운터 용도

esi : 이동명령



지역변수의 개수와 성능은 관련이 없다. 할당의 개념이 아니라 확보의 개념. 지역변수 1개와 천개는 esp 한방에 점프하는걸로 끝난다.
만약 함수가 하나 있을 때 그 안에서 변수를 선언하면 그 변수는 언제확보되느냔? 그 함수가 호출되는 시점에 확보가 끝난다. 
그래서 함수 내부에 조건문으로 감싸는게 성능이 낫지않을까 하는 생각이 의미없다. 함수를 들어오는 순간 모든 지역변수의 확보가 끝남.
변수가 3개 쓰이면 esp를 12바이트 점프하고 확보가 끝남. 


[ebp - 8]  : base pointer 기준으로 -8바이트 외에서부터 그 밑으로 4바이트 까지 사용하겠다. esp기준으로 +해서 내려와도 된다.

[ebp - 14h] : 16진수코드는 h가 붙음   


애초에 변수의 이름은 존재하지 않고 ebp의 위치를 기준으로 어느 위치에 있는 것을 쓸지만 있는 것 

프로세스가 시작하면 1메가 확보는 끝나고 어떻게 활용할지가 esp








