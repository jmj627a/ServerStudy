flag 객체에 방향성이 있다면 동기화 객체를 쓰지 않아도 된다. 
단지 true false이고 한쪽은 true로 변경만, 다른한쪽은 false로 변경만 한다면 하지 않아도 된다. 
무조건 값의 변경의 흐름이 한방향이라면 동기화를 하지 않아도 된다. shutdown은 동기화가 필요가 없다. 
true로 바꾸는건 main스레드에서만, 나머지 스레드는 확인만 할거니까. 

이벤트
뮤텍스나 세마포어도 내부적으로는 이벤트를 쓴다. 가장 기본적인 동기화 객체기 때문에. 
CreateEvent를 이용해서 호출. 결국 커널 오브젝트이기 때문에 sequrity attributes를 필요로함. 
reset 이건 용도에 맞게 써야함. 
setEvent . suspend와 resume은 count가 되다가 0이 되어야 했는데 setevent는 하나. 그냥 시그널 되는게 전부기때문에

resetevent. 오토reset에서는 필요없다. 메뉴얼reset을 대상으로 쓴다. 

이벤트는 언제쓰나? workerthread를 만들었을때. while문 돌면서, 어떤 상황이 주어지면 나으 ㅣ스레드 id를 출력하고 쉬고싶다. 
할일하고 빠지는 상황. 이벤트라는건 결국 시그널을 준다 뺀다라는거. cs랑 srwlock하고는 다른 느낌. 
내가 접근할거니까 아무도 접근못하게 하는 목적. 근데 이벤트같은애는 그냥 시그널을 기다리는거. 그러다가 시그널이 오면 꺠우자.
그럼 flag가 아니라 이벤트를 전역에다가 둔다. g_event를 createevent로 해서 만든다. 
그런다음에 waitforsingleobject (g_event, infinite) 함녀 시그널이 올떄까지 영ㅇ원히 블락됨. 
그리고 다른 메인에서 setevent(g_event)하면 됨. 그리고 메뉴얼reset이라면 내가 할일을 다하고나서 resetevent를 해야한다. 
동기화를 목적으로 나온게 아니라 스레드의 흐름을 제어하기 위해서 나온거다. 
메뉴얼 reset은 몇개의 스레드가 깨어날지 모르고 이렇게 쓰기위해 나온것. 딱 하나만 깨어나길 원하면 auto reset을 해야한다. 
근데 이제 메뉴얼 reset상태에서 일을 더 많이하기위해 worker thread를 하나 더 만들었따고 하자. 
그럼 많은애들중 하나가 깨어나서 일을하기 바라는거. 10초가 걸리는 길찾기를 한다던지. 복잡한일. 그럼 시그널을 줘도 
깨어날애가 없다면 안된다. 그래서 스레드를 많이 만들어두고, 그중 한놈이 꺠어나서 일을 하고 다음애가 요청하면 다음애가 일하고. 
다하면 블락걸리러 가고. 이게 스레드 풀이다. 근데 이렇게 스레드풀에서 잠들어있던애들은 다 꺠어난다 한놈이 아니라 
그래서 이럴땐 auto reset이 되어야 한다. 하나의 스레드만 깨우고 나머지는 논시그널. 
두번 일해야한다고 setevent를 두번해서 두개의 스레드가 깨는게 아니라 신호니까 그냥 하나만 꺠어남. 

그럼 메뉴얼 리셋은 언제쓰나? 의도적으로 다 꺠우고 싶을떄 쓴다. 예를들면 종료같은거 할떄. 
근데 이제 그럼 하나의 스레드가 2개의 이벤트를 기다려야한다. 원래 자기일하고, 종료일. 그럼 자기일은 single로 기다리고 종료는 multi로 기다린다. 
아니면 job중 하나로 종료를 넣어서 이걸 확인하고 종료면 종료하게 해도 된다. single로 기다리면 종료가 올때까지 막혀서 기다리게 되닌까.

이벤트는 waiting을 하러 들어간 순서 그대로 실행된다. 정말 뺑뺑이를 잘 돌린다. 근데 가장 좋은 환경은 방금 일 끝난 스레드가 
다시 실행되는게 제일 좋다. 왜? 캐시히트율도 높아질수있고 같은코어에서 실행되면 콘텍스트 스위치도 안일어나니까. 근데도 순서대로 실행된다.
근데 이 이벤트를 대상으로 어떤 스레드가 기다리는지 어떻게 아냐? 이벤트가 알아야한다. 누가 나를 기다리는지. 
그래서 이벤트 객체에 waitforsingleobject를 부르면 이벤트 안에 다 갖고있는다. 그래서 무조건 앞에것만 판단해서 순서대로 깨어나게 되어있따.
우리한텐 안타까운 상황. 

iocp는 스레드 풀이다. 워커스레드를 효율적으로 관리해주는 스레드 풀. 소켓 입출력모델중에 iocp가 있는게 아니다. 

pulseevent. 
정말 한번 줬다 빼는거. 메뉴얼 리셋이냐 오토리셋이냐에 따라 다르다. 
일단 메뉴얼 리셋인경우는 (c68쪽)
지금 대기중인 애만 한방에 싹 꺠우고 논시그널. 
결국 메뉴얼이든 오토든 잠깐 깨우긴 하는데 몇개를 꺠우는지 차이. 대기중인애들한테만 뭔가한다는 의미가 없어서 잘안씀.



srwlock은 완벽한 유저객체로서 유저모드에서만 돌아가기때문에 releaseSRWLOCKExclusive한다고 해서 커널의 뭔가 
전환이 있는게 아니라 대기중인애가 꺠어나는게 아니라, release한다음에 자기가 바로 aquire한다면 내가 다시 들어간다. 
다썼다는 신호는 들어가는데 다시 내가 락을 얻는다. 먼저 걔를 꺠우지 않는다. 
근데 만약 이벤트나 그런것처럼 누가 권한을 풀었다? 일반적인 cs옛날모델 뮤텍스 이런거 다 이벤트로 되어있으니까 
커널모드로 전환되면서 시그널을 주면서 대기중인 스레드 하나를 깨우면서 다른 스레드가 돌아가는데, 
커널모드로의 전환이 없으니까 블락중인 스레드를 꺠울수가 없다. 유저모드에서 동기화 객체가 작동되는 구조가 이해가 되지를 않는다.
근데 테스트해보고 작동방식 테스트해보면 그렇게 추측할뿐. sleep이 있다면 블락걸리면서 다른애들이 돌수가 있따.
커널모드로 전환이 되어야 다른애가 깨어나느데 어떻게 깨어나는지 작동방식은 언급되어있지 않다. 그 행위를 키드이벤트가 해준다고는 하는데 자료가없다.


entercriticalsection을 하고나서 
leave를 하려할떄 모든 if문마다 리턴이 있으면 항상 넣어야하니까 코드상으 ㅣ실수확률이 많아진다. 
이럴떄 c스타일은 do while(0)을 쓴다. 
do
{
	if() break;
	if() break;
	if() break;
}
while(0);
leavecriticalsection

이런식으로. goto랑 같은 느낌. 

욪므 많이쓰는건 
CLock lock(&cs);
로직 
if () return; 
로직 
if () return; 
이렇게 하면 객체의 소멸자 코드에서 알아서 해제를 해준다. 
근데 그럼 문제가 동기화 로직이 필요없는 부분도 다 끝까지 lock으로 묶여있다. 그런경우는 그 구간 덩어리를  { } 로 묶으면
소멸자 호출하면서 빠진다. 실무에서는 대부분 이런 방식으로 쓴다. 
성능은 당연히 더 느리다 .생성자 호출하고 소멸자 호출하고 함수호출량이 늘어난다. 
최적화 컴파일 해도 inline처리 되니까 괜찮은거아니냐? 생성자인가 소멸자 둘중하나는 인라인 처리가 안된다. 완벽하게 괜찮다 할수없음. 

----------------------------------------------------------------------------------------------------

스레드 관해서 캐시라인. 
캐시라인에 대한것. 다른 코어에 있는 캐시 메모리들은 날라가니까 그래서 캐시미스가 유도가 되고. 그래서 읽기용 쓰기용을 떨어트려놓자는거 
그리고 캐시라인에 걸쳐있었을때. 캐시라인에 걸쳐있으면 한번읽을거 두번에 읽으니 성능도 떨어지고, 다른스레드가 바꾸면 중간값이 읽힘.


동기화 객체는 무조건 데이터별로 만드는것도 아니다. 
데이터별로 하면 컨텐츠가 복잡한 게임같은 상황에선 적합하지 않다. 플레이어 아이템 다 각각 두면 데드락밖에 없다.
그럴바엔 덩어리로 간다. 게임이라 그러면 덩어리도 애매해짐. 지역별로 락을 건다거나. 


main thread같은건 지금같으면 블락거리는 키보드 인풋이 있어도 되는거. 
scanf나 getch나. 근데 만약ㅇ 주기적으로 돌면서 할게필요하다면 sleep(1)을 걸든 해서 천천히 돌려라. 
메인스레드 컨트롤러 느낌이면 천천히 돌리거나 블락걸리게 하는것도 방법. 

--------------------------------------------------------------------------------------------------------

이론으로 암기할 것 
여태까지 언급이 없었던 내용 

out of ordering 문제가 있다. 다른 프로세스의 커널메모리에 접근이 된다. 왜??? out of ordering 기능떄문에. 
명령어의 순서가 바뀌어서 cpu차원에서 먼저 처리가 된다는거. 그래서 접근할수없는곳까지 접근한다는거. 
그래도 cpu가 바보가 아니닌까 아무상관없다고 보이는걸 바꾼다. 근데 그걸로인해서 다른 스레드의 값이 바뀔수있고 
아주 미묘한 동기화 이슈가 발생할수있따는거. 근데 그런 상황이라면 애초에 락을 걸어서 이런 이슈가 발생되지 않는다. 

그래서 나오는게 메모리 베리어. 단어만 외우는게 아니라 작동방식까지도 다 
말그대로 장벽을 세워서 여기와 여기는 명령어를 뒤섞지 말라고 하는것. 

_mm_mfenfce 이 펜스를 기준으루 위와 아래를 재배치하지 마라. 위는 위끼리 해도 되고 아래는 아래끼리 해도 되는데 이 위와 아래는 섞지말라는거

_ReadWriteBarrier()
얘는 최적화 컴파일을 끄는거지 out of ordering을 끄는게 아니다. cpu의 out of ordering 기능에서 메모리 베리어가 있고 
최적화 컴파일에서의 메모리 베리어가 있다. 이렇게 쳐두면 이 위아래는 최적화 하지 말라는거. 존재하지 않는 코드 실제론. 
volatile은 그 변수 쓰는 지점만 최적화 컴파일하지말라는거였는데, 이 함수를 쓰면 여길 기준으로 위아래를 섞지말라는거. 
이건 cpu의 out of ordering과 다른거. 근데 사실 같이 설명한다. 어차피 최적화컴파일도 내가 한 순서대로 실행되지 않는건 같으니까.
그리고 ms도 이걸 비권장으로 한다. 그랫 ㅓ언급하는게 c++에 나오는 atomic_thread_fence를 쓰라는거..

atomic_thread_fence()
여기서 이 fence가 메모리 오더링에서의 펜스냐. 최적화 컴파일에서의 펜스냐. ?
컴파일러 베리어. 실제 어셈블러 보면 call도 없다. 기계어로 존재하는게 아니라, 컴파일러가 컴파일할떄 이걸 기준으로 위아래를 가르겠다는거지
어셈 결과물로 뭘 뽑겠다는게 아니다. 
안에서 내용물은 interlockcompareexchange가 (&guard, 0,0)으로 된다. 0에서 0으로 바꾸는거 의미없는 행위인데 
lock이라서 의미가 있다. 이게 메모리 베리어의 역할을 해준다. 근데 성능측정을 해보니 mfence보다 interlock이 더 빠르다는거. 
mfence는 그래서 지금 안쓰고 memory barrior을 쓰려고 하면 interlock 함수를 대용으로 쓴다. 그래서 이 함수도 이걸로 구현되어있는거. 
interlockincrement여도 되고 상관없다 interlock계열이면. 

__faststorefence()
는 더 빠르다고 하는데 sp 맨 위에 쓸데없는 지역 위치에 가서 락을 걸고있따. 이게 더 낫다. 위에 함수는 
static int guard전역으로 된 곳 가드에 가서 락을 걸고있따. 안그래도 interlock이 무거운데 다같이 값 동기화가 필요도없는데 동기화하고있따. 
근데 이건 그냥 지역에서 안쓰는 곳 락을 거는거니까 더 낫다.

















