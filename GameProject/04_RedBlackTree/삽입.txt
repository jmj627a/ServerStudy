enum NODE_COLOR
{
     BLACK = 0,
     RED
};

struct stNODE
{
     struct stNODE *pParent;
     struct stNODE *pLeft;
     struct stNODE *pRight;

     NODE_COLOR Color;

     int iData;
};


stNODE Nil; // 끝 리프노드. 무조건 블랙 / 데이터 무 / NULL 의 같은 용도.

Nil.Color = BLACK;
Nil.pParent = NULL;
Nil.pLeft = NULL;
Nil.pRight = NULL;





# 특징

1. 각 노드는 부모의 포인터를 가진다. (편의를 위해 일반적으로 그러 함)

2. 각 노드는 RED, BLOCK 의 색상값을 가진다.

3. 리프노드 (끝 잎노드) 를 표현하기 위해 Nil 이라는 공통된 노드를 사용한다.



# 노드 구성 조건

1. 모든 노드는 레드, 블랙 중 하나이다.

2. 루트 노드는 블랙 이다.

3. 리프(잎) 노드는 블랙 이다.

4. 레드 노드의 자식은 블랙 이다.

+ 블랙 노드의 자식은 무슨 색이든 가능
+ 레드 노드의 부모는 무조건 블랙

5. 루트노드 부터 리프노드 까지 모든 경로의 블랙의 수는 같다.



# 레드블랙 트리란 ?

- 위의 5가지 조건을 만족하는 이진서치 트리


# 위 조건을 만족하면 왜 성능이 좋은가 ?

- 이진트리의 검색 성능을 좌우하는 것은 리프노드 까지의 깊이의 밸런스.

- 한쪽으로의 쏠림이 적은 상태가 가장 최고의 상황.

- 레드블랙트리는 각노드에 레드,블랙의 상태를 만들어서

  레드 노드는 연달아 올 수 없으며,
 
  루트 > 리프 까지의 모든 경우에 대해 블랙 개수를 일치하게 한다.



== 15개 노드의 최고 상황 ==============================

 
                     B

              R                R

         B        B       B       B
 
      R    R    R   R   R   R   R   R
 
    N  N N  N N N N N N N N N N N N N

어떤 경우에도 4번만에 검색 가능. (15개 노드)

Root > Leaf 의 모든 경우에 대해 블랙 2회.



== 15개 노드의 레드블랙 최악 상황 =====================


                      B

             B                   R

         B       B         B          B
 
       N  N     N  N    B     B    R     R
                     
                       N N   N N  B  B   B   B

                                 NN  NN  NN  NN


3회 ~ 5회 만에 검색 가능. (15개 노드)


- 레드의 자식은 블랙 이어야 한다

- Root > Leaf 의 블랙 개수는 모두 같아야 한다.

  위 2개의 조건으로 인해서 깊이 밸런스에 최대최소 범위가 생겨나게 된다.








최단깊이 - 블랙노드로만 이루어진 경로

최장깊이 - 블랙과 레드가 반복되는 경로

고로 최장은 최단깊이 X 2 까지 가능.



이진서치 트리에서 최악의 상황

최단깊이 - 0

최장깊이 - (노드개수 - 1)

이런 가능성도 있으므로 레드블랙 트리는 전체 밸런스가 훨씬 좋은 이진트리임





# Leaf 를 표시하는 Nil 노드.

레드블랙 트리에서는 데이터를 사용하지 않는 더미노드를 하나 준비함.

이는 무조건 블랙노드이며,  모든 리프에 Nil 노드를 연결한다.

레드블랙의 3번조건, "모든 리프는 블랙이다" 의 조건을 만족하기 위한

NULL 대신 들어간 더미노드임.




# 모든 삽입과 삭제는 이진서치 트리를 기본으로 함.

삽입 및 삭제 후 레드,블랙의 밸런스를 맞추는 작업이 추가적으로 들어감.





# 노드의 회전

노드의 깊이 밸런스를 맞추기 위해 필요한 기본 기능은 회전.


- Node N 을 기준으로 우회전

       N

   A       D

 B   C   E   F


        < N 에서 우회전 >

       A

   B       N

        C     D

            E    F


N 의 왼쪽 자식 (A) 이 N 의 위치로 오며 N 은 왼쪽자식(A) 의 오른편으로 붙음.

이때 N 의 왼쪽자식 (A) 의 오른편 자식 (C) 은  N 의 왼편으로 붙음.




- Node N 을 기준으로 좌회전


       N

   A       D

 B   C   E   F


        < N 에서 좌회전 >

       D

     N    F

   A   E

 B   C  

N 의 오른 자식 (D) 이 N 의 위치로 오며 N 은 왼쪽자식(D) 의 왼편으로 붙음.

이때 N 의 오른자식 (D) 의 왼편 자식 (E) 은  N 의 오른편으로 붙음.








# 노드 삽입 후 밸런스 맞추기

새로 삽입되는 노드는 무조건 RED

새로 삽입되는 노드는 무조건 끝단에 들어감.




레드.블랙 트리 조건확인.

1. 모든 노드는 레드/블랙 이다.
2. 루트 노드는 블랙이다.
3. 리프 노드는 블랙이다.
4. 레드 노드의 자식은 블랙이다.
5. 루트부터 리프까지 어떤 경우에도 블랙 개수는 동일하다.


1. 기본임.
2. 루트는 그냥 블랙으로 대입 할꺼임
3. Nil 로 블랙노드 효과 내어줌.
4. 미해결상태.
5. 추가된 노드는 레드 이므로 블랙노드의 개수와는 상관이 없다.
   회전이 들어갈 경우 일부 블랙의 개수가 틀려지나 바로 맞춰 줄 것이다.


------------------------
신규 노드의 부모가 블랙이라면 전혀 문제가 없음.
아래의 문제 상황은 부모가 레드인 경우 해당됨.
------------------------


4번을 해결하기 위해서 삼촌 (부모의 형제) 노드의 색상을 확인 해야한다.

부모의 형제 노드를 확인하는 이유!  레드,블랙 트리에서의 가장 중요한 부분은

'모든 경로에 대한 블랙노드의 개수일치' 이다

새로운 노드가 추가되면, 삼촌노드와 블랙 개수가 맞추어져야 한다.

할아버지를 기준으로 좌우의 밸런스 !!!

(부모 > 할아버지 > 옆 자식)




- 4번 조건에 대한 문제 상황

1. 부모 레드, 삼촌도 레드.
2. 부모 레드, 삼촌은 블랙, 나는 부모의 오른쪽 레드, , .
3. 부모 레드, 삼촌은 블랙, 나는 부모의 왼쪽 레드, , .



















1. 부모와 삼촌을 블랙으로 바꾸고,  할아버지는 레드로 바꾼다.

   할아버지가 레드로 바뀜으로 인해서,  할아버지 상단의 색상도 모두 비교를 해보아야 한다.

   그래서 결국 ROOT 노드까지 올라가면서 이를 반복 확인 해야한다.

   할아버지를 새 노드로 잡고 다시 확인.




2. 나는 오른레드, 부모도 레드, 삼촌은 블랙 상황.

   색상만 맞추는걸로 끝내지 않고,  회전을 통해서 밸런스를 맞춰 준다.

   회전을 위해선 좌측 또는 우측의 한쪽 방향으로 노드가 몰려있는게 좋다.

   그러므로 우선  3번조건 상황으로 만든다.


   나는 레드,  부모의 오른쪽 노드,  부모도 레드, 인 경우에는

   부모기준으로 좌회전하여 신규노드를 부모의 위치로 올리고,

   부모를 신노드 왼쪽 자식으로 옮겨서 밸런스를 맞춘다.


   이로서 2번 상황은 3번 상황으로 변경 되었음.


   이를 하는 이유는 3번 상황에서 우회전을 통해 해결을 해야 하는데
 
   레드노드가 부모의 오른자식이면 할아버지 오른쪽으로 레드노드가 넘어간다.
 
   이때, 할아버지가 레드가 될 예정이므로 문제가 발생함.




3. 나는 왼레드, 부모도 레드, 삼촌은 블랙

   부모를 블랙으로

   할아버지는 레드로

   할아버지 기준으로 우회전!

   

# 모든 문제는 부모가 레드인 경우이므로 할아버지는 블랙이다.

a
- https://www.cs.usfca.edu/~galles/visualization/RedBlack.html
